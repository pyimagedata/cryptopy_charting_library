<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>TypeScript Charting Library</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background-color: #1a1a2e;
            height: 100vh;
            width: 100vw;
            overflow: hidden;
        }

        #chart {
            width: 100%;
            height: 100%;
        }
</style>
</head>
<body>
    <div id="chart"></div>

    <script src="packages/charts/dist/charts.js"></script>
    <script>
        // Default parameters
        let currentSymbol = 'BTCUSDT';
        let currentInterval = '1h';
        let currentExchange = 'BINANCE'; // BINANCE, BINANCE-FUTURES, BYBIT, BYBIT-FUTURES
        const LIMIT = 1000;

        // Initialize chart variables
        let chart;
        let currentSeries;
        
        // ========================================================================
        // Binance Data Fetcher
        // ========================================================================
        async function fetchBinanceData(symbol, interval, isFutures = false) {
            try {
                const MAX_PAGES = 2;
                let allData = [];
                let endTime = null;
                const baseUrl = isFutures 
                    ? 'https://fapi.binance.com/fapi/v1/klines'
                    : 'https://api.binance.com/api/v3/klines';

                console.log(`ðŸ“Š Fetching ${symbol} from Binance ${isFutures ? 'Futures' : 'Spot'}...`);
                const delay = ms => new Promise(resolve => setTimeout(resolve, ms));

                for (let i = 0; i < MAX_PAGES; i++) {
                    let url = `${baseUrl}?symbol=${symbol.toUpperCase()}&interval=${interval}&limit=1000`;
                    if (endTime) url += `&endTime=${endTime}`;

                    const response = await fetch(url);
                    if (!response.ok) break;
                    
                    const rawData = await response.json();
                    if (rawData.length === 0) break;

                    const pageData = rawData.map(d => ({
                        time: d[0],
                        open: parseFloat(d[1]),
                        high: parseFloat(d[2]),
                        low: parseFloat(d[3]),
                        close: parseFloat(d[4]),
                        volume: parseFloat(d[5])
                    }));

                    allData = [...pageData, ...allData];
                    endTime = pageData[0].time - 1;
                    if (rawData.length < LIMIT) break;
                    if (i < MAX_PAGES - 1) await delay(300);
                }

                allData.sort((a, b) => a.time - b.time);
                return allData.filter((v, i, a) => i === 0 || v.time !== a[i-1].time);
            } catch (error) {
                console.error('âŒ Error fetching Binance data:', error);
                return [];
            }
        }

        // ========================================================================
        // Bybit Data Fetcher
        // ========================================================================
        async function fetchBybitData(symbol, interval, isFutures = false) {
            try {
                // Convert interval to Bybit format
                const intervalMap = {
                    '1m': '1', '3m': '3', '5m': '5', '15m': '15', '30m': '30',
                    '1h': '60', '2h': '120', '4h': '240', '6h': '360', '12h': '720',
                    '1d': 'D', '1w': 'W', '1M': 'M'
                };
                const bybitInterval = intervalMap[interval] || '60';
                const category = isFutures ? 'linear' : 'spot';

                console.log(`ðŸ“Š Fetching ${symbol} from Bybit ${isFutures ? 'Futures' : 'Spot'}...`);

                const url = `https://api.bybit.com/v5/market/kline?category=${category}&symbol=${symbol}&interval=${bybitInterval}&limit=200`;
                const response = await fetch(url);
                
                if (!response.ok) throw new Error(`Bybit API error: ${response.status}`);
                
                const data = await response.json();
                if (data.retCode !== 0 || !data.result?.list) {
                    throw new Error(`Bybit API error: ${data.retMsg}`);
                }

                // Bybit returns [startTime, open, high, low, close, volume, turnover]
                // Sorted newest first, we need oldest first
                return data.result.list.reverse().map(c => ({
                    time: parseInt(c[0]),
                    open: parseFloat(c[1]),
                    high: parseFloat(c[2]),
                    low: parseFloat(c[3]),
                    close: parseFloat(c[4]),
                    volume: parseFloat(c[5])
                }));
            } catch (error) {
                console.error('âŒ Error fetching Bybit data:', error);
                return [];
            }
        }

        // ========================================================================
        // OKX Data Fetcher
        // ========================================================================
        async function fetchOkxData(symbol, interval, isFutures = false) {
            try {
                // Convert interval to OKX format
                const intervalMap = {
                    '1m': '1m', '3m': '3m', '5m': '5m', '15m': '15m', '30m': '30m',
                    '1h': '1H', '2h': '2H', '4h': '4H', '6h': '6H', '12h': '12H',
                    '1d': '1D', '1w': '1W', '1M': '1M'
                };
                const bar = intervalMap[interval] || '1H';
                
                // Symbol already comes in correct format from symbol search (BTC-USDT or BTC-USDT-SWAP)
                let instId = symbol;
                
                // Only add -SWAP suffix if futures and not already present
                if (isFutures && !instId.includes('-SWAP')) {
                    instId = instId + '-SWAP';
                }

                console.log(`ðŸ“Š Fetching ${instId} from OKX ${isFutures ? 'Futures' : 'Spot'}...`);

                const url = `https://www.okx.com/api/v5/market/candles?instId=${instId}&bar=${bar}&limit=300`;
                const response = await fetch(url);
                
                if (!response.ok) throw new Error(`OKX API error: ${response.status}`);
                
                const data = await response.json();
                if (data.code !== '0' || !data.data) {
                    throw new Error(`OKX API error: ${data.msg}`);
                }

                // OKX returns [ts, open, high, low, close, vol, ...]
                // Sorted newest first, we need oldest first
                return data.data.reverse().map(c => ({
                    time: parseInt(c[0]),
                    open: parseFloat(c[1]),
                    high: parseFloat(c[2]),
                    low: parseFloat(c[3]),
                    close: parseFloat(c[4]),
                    volume: parseFloat(c[5])
                }));
            } catch (error) {
                console.error('âŒ Error fetching OKX data:', error);
                return [];
            }
        }

        // ========================================================================
        // Universal Data Fetcher
        // ========================================================================
        async function fetchData(symbol, interval, exchange) {
            switch(exchange) {
                case 'BINANCE':
                    return fetchBinanceData(symbol, interval, false);
                case 'BINANCE-FUTURES':
                    return fetchBinanceData(symbol, interval, true);
                case 'BYBIT':
                    return fetchBybitData(symbol, interval, false);
                case 'BYBIT-FUTURES':
                    return fetchBybitData(symbol, interval, true);
                case 'OKX':
                    return fetchOkxData(symbol, interval, false);
                case 'OKX-FUTURES':
                    return fetchOkxData(symbol, interval, true);
                default:
                    console.warn(`Unknown exchange: ${exchange}, falling back to Binance`);
                    return fetchBinanceData(symbol, interval, false);
            }
        }

        // ========================================================================
        // WebSocket for Real-time Updates
        // ========================================================================
        let currentWebSocket = null;

        function subscribeToWebSocket(symbol, interval, exchange) {
            // Close existing WebSocket
            if (currentWebSocket) {
                currentWebSocket.close();
                currentWebSocket = null;
            }

            // Route to appropriate WebSocket based on exchange
            if (exchange.startsWith('BINANCE')) {
                subscribeToBinanceWS(symbol, interval, exchange === 'BINANCE-FUTURES');
            } else if (exchange.startsWith('BYBIT')) {
                subscribeToBybitWS(symbol, interval, exchange === 'BYBIT-FUTURES');
            } else if (exchange.startsWith('OKX')) {
                subscribeToOkxWS(symbol, interval, exchange === 'OKX-FUTURES');
            } else {
                console.log('â¸ï¸ WebSocket not available for:', exchange);
            }
        }

        // ========================================================================
        // Binance WebSocket
        // ========================================================================
        function subscribeToBinanceWS(symbol, interval, isFutures) {
            const wsUrl = isFutures 
                ? 'wss://fstream.binance.com/ws'
                : 'wss://stream.binance.com:9443/ws';
            
            const streamName = `${symbol.toLowerCase()}@kline_${interval}`;
            
            currentWebSocket = new WebSocket(`${wsUrl}/${streamName}`);
            
            currentWebSocket.onopen = () => {
                console.log(`ðŸŸ¡ Binance WebSocket connected: ${streamName}`);
            };
            
            currentWebSocket.onmessage = (event) => {
                try {
                    const data = JSON.parse(event.data);
                    if (data.e === 'kline') {
                        const k = data.k;
                        const candle = {
                            time: k.t,
                            open: parseFloat(k.o),
                            high: parseFloat(k.h),
                            low: parseFloat(k.l),
                            close: parseFloat(k.c),
                            volume: parseFloat(k.v)
                        };
                        updateChartWithCandle(candle, k.x);
                    }
                } catch (e) {
                    console.error('Binance WebSocket parse error:', e);
                }
            };
            
            currentWebSocket.onerror = (error) => console.error('âŒ Binance WebSocket error:', error);
            currentWebSocket.onclose = () => console.log('ðŸŸ¡ Binance WebSocket disconnected');
        }

        // ========================================================================
        // Bybit WebSocket
        // ========================================================================
        function subscribeToBybitWS(symbol, interval, isFutures) {
            const wsUrl = isFutures 
                ? 'wss://stream.bybit.com/v5/public/linear'
                : 'wss://stream.bybit.com/v5/public/spot';
            
            // Convert interval to Bybit format
            const intervalMap = {
                '1m': '1', '3m': '3', '5m': '5', '15m': '15', '30m': '30',
                '1h': '60', '2h': '120', '4h': '240', '6h': '360', '12h': '720',
                '1d': 'D', '1w': 'W'
            };
            const bybitInterval = intervalMap[interval] || '60';
            
            currentWebSocket = new WebSocket(wsUrl);
            
            currentWebSocket.onopen = () => {
                console.log(`ðŸŸ£ Bybit WebSocket connected`);
                // Subscribe to kline
                const subscribeMsg = {
                    op: 'subscribe',
                    args: [`kline.${bybitInterval}.${symbol}`]
                };
                currentWebSocket.send(JSON.stringify(subscribeMsg));
            };
            
            currentWebSocket.onmessage = (event) => {
                try {
                    const data = JSON.parse(event.data);
                    // Bybit kline format: { topic: "kline.1.BTCUSDT", data: [...] }
                    if (data.topic && data.topic.startsWith('kline.') && data.data) {
                        for (const k of data.data) {
                            const candle = {
                                time: parseInt(k.start),
                                open: parseFloat(k.open),
                                high: parseFloat(k.high),
                                low: parseFloat(k.low),
                                close: parseFloat(k.close),
                                volume: parseFloat(k.volume)
                            };
                            updateChartWithCandle(candle, k.confirm);
                        }
                    }
                } catch (e) {
                    console.error('Bybit WebSocket parse error:', e);
                }
            };
            
            currentWebSocket.onerror = (error) => console.error('âŒ Bybit WebSocket error:', error);
            currentWebSocket.onclose = () => console.log('ðŸŸ£ Bybit WebSocket disconnected');
        }

        // ========================================================================
        // OKX WebSocket
        // ========================================================================
        function subscribeToOkxWS(symbol, interval, isFutures) {
            // OKX Candlesticks require the /business endpoint, NOT /public
            const wsUrl = 'wss://ws.okx.com:8443/ws/v5/business';
            
            // Convert interval to OKX format
            const intervalMap = {
                '1m': '1m', '3m': '3m', '5m': '5m', '15m': '15m', '30m': '30m',
                '1h': '1H', '2h': '2H', '4h': '4H', '6h': '6H', '12h': '12H',
                '1d': '1D', '1w': '1W'
            };
            const okxInterval = intervalMap[interval] || '1H';
            
            // Symbol already in OKX format (BTC-USDT or BTC-USDT-SWAP)
            const instId = symbol;
            
            currentWebSocket = new WebSocket(wsUrl);
            
            currentWebSocket.onopen = () => {
                console.log(`âš« OKX WebSocket connected`);
                // Subscribe to candle
                const subscribeMsg = {
                    op: 'subscribe',
                    args: [{ channel: `candle${okxInterval}`, instId: instId }]
                };
                console.log('âš« OKX Subscribing:', JSON.stringify(subscribeMsg));
                currentWebSocket.send(JSON.stringify(subscribeMsg));
            };
            
            currentWebSocket.onmessage = (event) => {
                try {
                    const data = JSON.parse(event.data);
                    
                    // Log subscription response
                    if (data.event) {
                        console.log('âš« OKX Event:', data.event, data.code, data.msg);
                        return;
                    }
                    
                    // OKX candle format: { arg: { channel, instId }, data: [[ts, o, h, l, c, vol, ...]] }
                    if (data.data && data.arg?.channel?.startsWith('candle')) {
                        for (const k of data.data) {
                            const candle = {
                                time: parseInt(k[0]),
                                open: parseFloat(k[1]),
                                high: parseFloat(k[2]),
                                low: parseFloat(k[3]),
                                close: parseFloat(k[4]),
                                volume: parseFloat(k[5])
                            };
                            updateChartWithCandle(candle, false);
                        }
                    }
                } catch (e) {
                    console.error('OKX WebSocket parse error:', e);
                }
            };
            
            currentWebSocket.onerror = (error) => console.error('âŒ OKX WebSocket error:', error);
            currentWebSocket.onclose = (event) => console.log('âš« OKX WebSocket disconnected, code:', event.code, event.reason);
        }

        function updateChartWithCandle(candle, isClosed) {
            const series = chart.model.serieses[0];
            if (!series || !series.data || series.data.length === 0) return;

            const lastCandle = series.data[series.data.length - 1];
            
            // If same timestamp, update existing candle
            if (lastCandle.time === candle.time) {
                lastCandle.high = Math.max(lastCandle.high, candle.high);
                lastCandle.low = Math.min(lastCandle.low, candle.low);
                lastCandle.close = candle.close;
                lastCandle.volume = candle.volume;
            } else if (candle.time > lastCandle.time) {
                // New candle, add to series
                series.data.push(candle);
                chart.model.timeScale.setPointsCount(series.data.length);
            }
            
            // Trigger update
            chart.model.fullUpdate();
        }

        async function updateChartData(symbol, interval, exchange) {
            // Show loading indicator
            chart.setLoading(true, `Loading ${symbol} from ${exchange}...`);
            
            try {
                const data = await fetchData(symbol, interval, exchange);
                if (data.length > 0) {
                    const series = chart.model.serieses[0];
                    if (series) {
                        chart.setData(series, data);
                        chart.model.timeScale.scrollToPosition(0, false);
                        chart.model.fullUpdate();
                        console.log(`âœ… Loaded ${data.length} candles for ${symbol} from ${exchange}`);
                        
                        // Subscribe to WebSocket for real-time updates
                        subscribeToWebSocket(symbol, interval, exchange);
                    }
                } else {
                    alert(`${symbol} verisi ${exchange}'dan Ã§ekilemedi.`);
                }
            } finally {
                chart.setLoading(false);
            }
        }

        async function initChart() {
            // Create full screen chart
            chart = LightweightCharts.createChart('#chart', {
                 layout: {
                     backgroundColor: '#1a1a2e',
                     textColor: '#d1d4dc',
                 },
                 grid: {
                     vertLines: { color: 'rgba(42, 46, 57, 0.5)' },
                     horzLines: { color: 'rgba(42, 46, 57, 0.5)' },
                 }
            });

            // Add candlestick series
            currentSeries = chart.addCandlestickSeries({
                upColor: '#26a69a',
                downColor: '#ef5350',
                borderVisible: false,
                wickVisible: true
            });

            // Listen for symbol changes (now includes exchange info)
            chart.symbolChanged.subscribe(async (symbolInfo) => {
                // symbolInfo can be string (old) or object (new with exchange)
                if (typeof symbolInfo === 'object' && symbolInfo.exchange) {
                    currentSymbol = symbolInfo.symbol;
                    currentExchange = symbolInfo.exchange;
                    console.log(`ðŸ”„ Symbol changed to: ${currentSymbol} @ ${currentExchange}`);
                } else {
                    currentSymbol = symbolInfo;
                    // Keep current exchange if it's just a symbol string
                }
                await updateChartData(currentSymbol, currentInterval, currentExchange);
            });

            // Listen for timeframe changes
            chart.timeframeChanged.subscribe(async (newInterval) => {
                let interval = newInterval.toLowerCase();
                if (interval === 'd') interval = '1d';
                if (interval === 'w') interval = '1w';
                
                currentInterval = interval;
                await updateChartData(currentSymbol, currentInterval, currentExchange);
            });
            
            // Initial load
            await updateChartData(currentSymbol, currentInterval, currentExchange);
        }

        document.addEventListener('DOMContentLoaded', initChart);
    </script>
</body>
</html>
